\section{Introduction}
% no \IEEEPARstart

\subsection{History}
Blockchain was introduced for the first time about 10 years ago, when Satoshi
Nakamoto, an anonymous Japanese\footnote{Actually, experts thinks that Satoshi
Nakamoto is an alias for a group of people and that no one with that name
really exists.} user in 2008 designed it in order to create a virtual currency,
Bitcoin. Since then, the Blockchain technology has developed to new frontiers,
establishing new ways to interpret money and payments. Not only, it's currently
studied in different fields than the financial one.

\subsection{Blockchain overview}
Blockchain was designed in order to solve the double-spending problem in
online transactions without any third party checking\cite{nakamoto08}. To
achieve this, it rely on a peer-to-peer system, where every user hold a copy of
the whole database.

Every transaction is hashed and stored in a block, and blocks are connected in
a list. These block are generated by the network members, in a process called
`mining'. When users are mining, they contribute generating and validating new
blocks, thanks to `proof-of-work' puzzles. When a block is generated, a
reward is released from the network, compensating the users that spent
computational time to generate and validate the transaction block.

Blockchain database differs from other types of databases because it doesn't
allow to modify or delete saved data, but only to add new information.

\subsection{Technical Analysis}

As mentioned above, a Blockchain database is composed of three different
parts\cite{sok15}:
\begin{itemize}
 \item Transactions
 \item Blocks concatenated in a list
 \item Peer-to-peer network
\end{itemize}

In this section we will see every component and how it behave.

\subsubsection{Transaction}
It represents a value's movement between a user $A$ and another (let's
say $B$). A transaction contain an array of outputs and an array of
inputs\cite{sok15}: the outputs sum must be less or equal than the inputs sum. 
This container is usually hashed with SHA-256, in order to have a
unique ID.

A transaction change the database state, making it a list of growing 
transactions.
In order to validate a transaction, we need to sign it in some way. Asymmetric
keys are mandatory in this process.

If $A$ want to sends money to $B$ it needs to:
\begin{itemize}
 \item Sign (with his private key) the previous hashed transaction and sign the
public key of the next owner ($B$)
 \item Save all the signatures in the chain
\end{itemize}

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.35]{transaction}
 \caption{A typical series of transactions}
\end{figure}

Several problems arise from this:
\begin{itemize}
 \item No one can guarantee the transaction validity
 \item $A$ could spend two times the same value
\end{itemize}

\paragraph*{Transaction Validity}
The list of transactions could be verified thanks to the chain of ownership:
in fact, every users has a local copy of the database so it has the possibility
to check the whole transaction history and define if the transaction is valid.

\paragraph*{Double spending problem}
The easiest solution could be ensuring a third-party to check all the
transaction, searching for possible frauds. This will establish an entity
that act like a bank, against the Blockchain design. On top of this,
the entity could act arbitrarily, for instance denying payments to specific
groups of people.

To ensure that $A$ is giving moneys that were not already used, $B$ need to
check all the transactions. In this case, only the earliest is 
valid\cite{nakamoto08}. This leads to two minor problems:
\begin{enumerate}
 \item $B$ need to have a list of all the transaction
 \item $A$ could try to pay $B$ and $C$ with the same money in a very short
span of time, causing dispute to who should receive the payment.
\end{enumerate}

\paragraph*{Transactions updates}
\label{TU}
$B$ needs all the transactions in order to be able to recognize a possible
fraud from $A$. To accomplish this all the transactions have to be broadcast to
everyone in the network, making it publicly available.

\paragraph*{Timestamps}
To solve this problem every transaction need to be timestamped. A timestamp is 
given to a transaction and it's added to its hash. In order to eliminate every 
possibility of alterations, the previous transaction timestamp is added into 
the hash too.

\subsubsection{Block}
A list of transactions are put in a set called \textit{block}. Every block has
a link to the previous and another to the next, forming the real 
\textbf{blockchain}.
The blocks order is defined by the timestamp inside every transaction.

Sometimes it could happen that a list of blocks fork from the main chain. In
this case, the shortest chain will be eventually discarded, and all the miners
will restart working on the longest\cite{sok15}.

\subsubsection{Peer-to-Peer Network}

Blockchain is a peer-to-peer database, meaning that there isn't a central
server that store all the data, but the information is spread through all the 
peers.
In this way anyone in the network owns a copy of the whole database. The first
time a peer connect to the network it has to wait and get in sync with the 
other peers. In the meantime, no operation is permitted. A Blockchain database 
can grow a lot during the years. For example, Bitcoin's 
Blockchain\footnote{N.B.: this is a 8 years old database.} size is roughly 
100GB\footnote{GB = GigaByte}. This could be an issue initially for the new 
members of the network. We will see how this problem can be solved.
As said in \ref{TU}, every transaction is broadcast through the network so when
the miners mine a new block every peer starts to download it.

\subsection{Proof-of-Work}
% need to speak about this, it's important
