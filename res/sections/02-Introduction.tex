\section{Introduction}
% no \IEEEPARstart

\subsection{History}
Blockchain was introduced for the first time about 10 years ago, when Satoshi
Nakamoto, an anonymous Japanese\footnote{Actually, experts thinks that Satoshi
Nakamoto is an alias for a group of people and that no one with that name
really exists.} user in 2008 designed it in order to create a virtual currency,
Bitcoin. Since then, the Blockchain technology has developed to new frontiers,
establishing new ways to interpret money and payments. Not only, it is currently
studied in different fields than the financial one.

\subsection{Structure of the paper}

This paper is organized as follows: Section~\ref{sec:block_design} describes
how Blockchain is designed and how it works, making a technical analysis of this
technology and talking about its security issues, while
Section~\ref{sec:crypto_corr} provides an overview of the
use of this application in its main field: cryptocurrency.
Section~\ref{sec:beyond_crypto} describes new way to use this technology, while
Section~\ref{sec:attacks} lists the possible attacks and threat that this
database can suffer.

\section{Blockchain design}
\label{sec:block_design}
Blockchain was designed in order to solve the double-spending problem in
online transactions without any third party checking\cite{nakamoto08}. To
achieve this, it relies on a peer-to-peer system, where every user hold a copy
of the whole database.

Every transaction is hashed and stored in a block, and blocks are connected in
a list. These block are generated by the network members, in a process called
`mining'. When users are mining, they contribute generating and validating new
blocks, thanks to `proof-of-work' puzzles. When a block is generated, a
reward is released from the network, compensating the users that spent
computational time to generate and validate the transaction block.

Blockchain implementations, especially for the financial one, do not allow to
modify or delete saved data, but only to add new information. This is done to
prevent any transaction forgery by attackers, although it does not stop the
possibility for an attacker to add new material that invalidate the old one.

\subsection{Technical Analysis}

As mentioned above, a Blockchain database is composed of three different
parts\cite{sok15}:
\begin{itemize}
 \item Transactions
 \item Blocks concatenated in a list
 \item Peer-to-peer network
\end{itemize}

In this section we will see every component and how it behave.

\subsubsection{Transaction}
It represents a value's movement between user $A$ and another (let's
say $B$). A transaction contains an array of outputs and an array of
inputs\cite{sok15}: the sum of outputs must be less or equal than the sum of
the inputs.
This container is usually hashed with SHA-256, in order to have a
unique ID.

A transaction change the database state, making it a list of growing
transactions.
In order to validate a transaction, we need to sign it in some way. Asymmetric
keys are mandatory in this process.

If $A$ want to sends money to $B$ it needs to:
\begin{itemize}
 \item Sign (with his private key) the previous hashed transaction and sign the
public key of the next owner ($B$)
 \item Save all the signatures in the chain
\end{itemize}

\begin{figure}[ht]
 \centering
 \includegraphics[scale=0.35]{transaction}
 \caption{A typical series of transactions}
\end{figure}

Several problems arise from this:
\begin{itemize}
 \item No one can guarantee the transaction validity
 \item $A$ could spend two times the same value
\end{itemize}

\paragraph*{Transaction Validity}
The list of transactions could be verified thanks to the chain of ownership:
in fact, every user has a local copy of the database so it has the possibility
to check the whole transaction history and define if the transaction is valid.

\paragraph*{Double spending problem}
The easiest solution could be ensuring a third-party to check all the
transaction, searching for possible frauds. This will establish an entity
that act like a bank, against the Blockchain design. On top of this,
the entity could act arbitrarily, for instance denying payments to specific
groups of people.

To ensure that $A$ is giving moneys that were not already used, $B$ need to
check all the transactions. In this case, only the earliest is
valid\cite{nakamoto08}. This leads to two minor problems:
\begin{enumerate}
 \item $B$ needs to have a list of all the transaction
 \item $A$ could try to pay $B$ and $C$ with the same amount of money in a very
short span of time, causing dispute to who should receive the payment.
\end{enumerate}

\paragraph*{Transactions updates}
\label{TU}
$B$ needs all the transactions in order to be able to recognize a possible
fraud from $A$. To accomplish this all the transactions have to be broadcast to
everyone in the network, making it publicly available.

\paragraph*{Timestamps}
To solve this problem every transaction need to be timestamped. A timestamp is
given to a transaction and it is added to its hash. In order to eliminate every
possibility of alterations, the previous transaction timestamp is added into
the hash too.

\subsubsection{Block}
A set of transactions are put in a place together called \textit{block}. Every
block has a link to the previous one and another to the next one, forming
indeed the \textbf{blockchain}.
The blocks order is defined by the timestamp inside every transaction.

\label{fork}
Sometimes it could happen that a list of blocks fork from the main chain. In
this case, the shortest chain will be eventually discarded, and all the miners
will restart working on the longest\cite{sok15}.

\subsubsection{Peer-to-Peer Network}

Blockchain is a peer-to-peer database, meaning that there is not a central
server that store all the data, but the information is spread through all the
peers.
In this way anyone in the network owns a copy of the whole database. The first
time a peer connects to the network it has to wait and get in sync with the
other peers. In the meantime, no operation is permitted. A Blockchain database
can grow a lot during the years. For example, Bitcoin's
Blockchain\footnote{N.B.: this is a 8 years old database.} size is roughly
100GB\footnote{GB = GigaByte}. This could be an issue initially for the new
members of the network.
This great amount of data can be reduced though if transactions are hashed in a
Merkle tree, that is a data structure similar to a binary tree. In a complete
binary tree we have that every internal node has two children. A Merkle tree is
a complete binary tree where every internal node has a label that is the hash
of the labels or values of its children\cite{szydlo04}. The advantage of using
this technique is that only the root of the tree needs to be stored in the
block and not all the transactions\cite{nakamoto08} (thus saving space), on the
other hand this require additional computational time to check all the
transactions tree. Moreover, there is the possibility of what is called a
\textit{second preimage} attack on the Merkle root, where an attacker could
change part of the tree with another that has the same hash\cite{rogaway04}. In
order to mitigate this attack a preimage attack resistant hash algorithm should
be choose.


As said in \ref{TU}, every transaction is broadcast through the network so when
the miners mine a new block every peer starts to download it.

% TODO there are more than one mining algorithm! subsection for mining
%algorithm and a paragraph for ``proof-of-work''
\subsection{Mining algorithms}
In a Blockchain database, peers can emit new transactions in the network. These
need to be added into blocks and these blocks need to be concatenated in order
to form a block chain. This process is performed by \textbf{miners}.
There are different ways to attach blocks, and this depends on the mining
algorithm used: first of all, you could elect one miner every block and give
it the task to build the next block. This approach works only if all the miners
are trusted, because if there is only one miner infected or not trusted he
could mine a block with non-authorized transaction, thus attacking the
Blockchain. Another solution could be allowing only a very-restricted number of
computers to mine the Blockchain: supposing they are all trustworthy this
approach would fail the initial Blockchain design, centralizing the
network.
A solution that has kicked off well seems to be the one where all the nodes in
the network are allowed to mine, and the first one who solves a
computational-intensive puzzle can attach the block to the existing chain,
receiving a reward for the work made. We will see an example of this approach,
called \textbf{proof-of-work}.


\paragraph{Proof-of-Work}

The peers have to solve a computational problem, based on the \textit{one-way}
hash property. This property says that it is computationally infeasible to find
an $x$ such that $H(x) = h$.
In every block a \textit{nonce} field is added, and miners have to found an
hash for that block that its value is less than the previous one\cite{sok15}.
The only solution to solve this problem is to try every possible nonce
combination that result in an hash that is less than the previous. Every time a
new block is added to the block chain, the problem becomes computationally more
difficult to solve.
When two different miners found a different solution a fork can happen. As
already said above (\ref{fork}), only the longest chain is kept eventually.

Every time a puzzle is solved the miners (that can form groups called
\textit{pools}) typically gain a reward. This reward is important to keep miners
working on the block chain. Also, we will see how this reward is important when
a Blockchain database is used in a cryptocurrency.

This method was proposed for preventing abuse such e-mail spam, and for this
reason is called \textit{proof-of-work}\cite{back02}.

\subsection{The forking problem}

The last block in a blockchain is defined as \textit{head}. When a
\textbf{fork} happen, new heads are formed.

After a miner finishes its proof-of-work thus solving the computational puzzle
it will try to attach its block to the chain, in order to gain a reward (if
any). There is the possibility that two miners will found a good solution for
the same block and that they will try to attach to the blockchain at the same
time: this will result in the blockchain splitting, operation known also as
\textbf{forking}. In this kind of fork miners will work on one branch of the
chain, attaching blocks: eventually, one of the blockchain will prevail on the
others. When this happens, the other branches will be discarded, and the blocks
forming this branches will become \textit{orphan blocks}~\cite{decker13}.
Miners that mine orphan blocks likely will not receive any reward.

Usually this kind of forks are not a threat when the computational power is
distributed in an uniform manner through the network, but when one member has a
lot of it it could be a security issue. In fact, a member could try to carry on
a \textit{fork attack}. In order to succeed, the attacker branch (let's call it
$B_A$) needs to ``race''~\cite{nakamoto08} with the honest one (that for the
sake of simplicity we call it $B_H$) and to overtake it. To be able to have
$B_A > B_H$ the attacker needs to have more computational power than the rest of
the network, in other words more than $51\%$ of it.
If this attack succeed, the attacker is able to make her chain ($B_A$) with
altered transaction the honest chain $B_H$.
In an financial application, the attacker will not be able to add unlimited
founds to his wallet or to change arbitrary transaction (since every
transaction is signed and honest node will not accept forged transactions), but
will be able to change his own transaction and to take the money back.

Forks are used in different system to handle mining software update easily, or
even to change on purpose the content of a transaction. In the first case these
kind of forks are called \textit{soft forks} where there is a change in the
Blockchain structure that is retro-compatible with the current chain rules, in
the second case are called \textit{hard forks} and the changes are so deep that
miner that have not updated its mining software will see new transactions
as invalid. An example of hard forks is what split the cryptocurrency Ethereum
in two versions, Ethereum Classic and Ethereum.
