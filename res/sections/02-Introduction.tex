\section{Introduction}
% no \IEEEPARstart

\subsection{History}
Blockchain was introduced for the first time about 10 years ago, when Satoshi
Nakamoto, an anonymous Japanese\footnote{Actually, experts thinks that Satoshi
Nakamoto is an alias for a group of people and that no one with that name
really exists.} user in 2008 designed it in order to create a virtual currency,
Bitcoin. Since then, the Blockchain technology has developed to new frontiers,
establishing new ways to interpret money and payments. Not only, it's currently
studied in different fields than the financial one.

\section{Blockchain design}
Blockchain was designed in order to solve the double-spending problem in
online transactions without any third party checking\cite{nakamoto08}. To
achieve this, it relies on a peer-to-peer system, where every user hold a copy
of the whole database.

Every transaction is hashed and stored in a block, and blocks are connected in
a list. These block are generated by the network members, in a process called
`mining'. When users are mining, they contribute generating and validating new
blocks, thanks to `proof-of-work' puzzles. When a block is generated, a
reward is released from the network, compensating the users that spent
computational time to generate and validate the transaction block.

Blockchain database differs from other types of databases because it doesn't
allow to modify or delete saved data, but only to add new information.

\subsection{Technical Analysis}

As mentioned above, a Blockchain database is composed of three different
parts\cite{sok15}:
\begin{itemize}
 \item Transactions
 \item Blocks concatenated in a list
 \item Peer-to-peer network
\end{itemize}

In this section we will see every component and how it behave.

\subsubsection{Transaction}
It represents a value's movement between a user $A$ and another (let's
say $B$). A transaction contain an array of outputs and an array of
inputs\cite{sok15}: the outputs sum must be less or equal than the inputs sum.
This container is usually hashed with SHA-256, in order to have a
unique ID.

A transaction change the database state, making it a list of growing
transactions.
In order to validate a transaction, we need to sign it in some way. Asymmetric
keys are mandatory in this process.

If $A$ want to sends money to $B$ it needs to:
\begin{itemize}
 \item Sign (with his private key) the previous hashed transaction and sign the
public key of the next owner ($B$)
 \item Save all the signatures in the chain
\end{itemize}

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.35]{transaction}
 \caption{A typical series of transactions}
\end{figure}

Several problems arise from this:
\begin{itemize}
 \item No one can guarantee the transaction validity
 \item $A$ could spend two times the same value
\end{itemize}

\paragraph*{Transaction Validity}
The list of transactions could be verified thanks to the chain of ownership:
in fact, every users has a local copy of the database so it has the possibility
to check the whole transaction history and define if the transaction is valid.

\paragraph*{Double spending problem}
The easiest solution could be ensuring a third-party to check all the
transaction, searching for possible frauds. This will establish an entity
that act like a bank, against the Blockchain design. On top of this,
the entity could act arbitrarily, for instance denying payments to specific
groups of people.

To ensure that $A$ is giving moneys that were not already used, $B$ need to
check all the transactions. In this case, only the earliest is
valid\cite{nakamoto08}. This leads to two minor problems:
\begin{enumerate}
 \item $B$ need to have a list of all the transaction
 \item $A$ could try to pay $B$ and $C$ with the same money in a very short
span of time, causing dispute to who should receive the payment.
\end{enumerate}

\paragraph*{Transactions updates}
\label{TU}
$B$ needs all the transactions in order to be able to recognize a possible
fraud from $A$. To accomplish this all the transactions have to be broadcast to
everyone in the network, making it publicly available.

\paragraph*{Timestamps}
To solve this problem every transaction need to be timestamped. A timestamp is
given to a transaction and it's added to its hash. In order to eliminate every
possibility of alterations, the previous transaction timestamp is added into
the hash too.

\subsubsection{Block}
A list of transactions are put in a set called \textit{block}. Every block has
a link to the previous and another to the next, forming the real
\textbf{blockchain}.
The blocks order is defined by the timestamp inside every transaction.

\label{fork}
Sometimes it could happen that a list of blocks fork from the main chain. In
this case, the shortest chain will be eventually discarded, and all the miners
will restart working on the longest\cite{sok15}.

\subsubsection{Peer-to-Peer Network}

Blockchain is a peer-to-peer database, meaning that there isn't a central
server that store all the data, but the information is spread through all the
peers.
In this way anyone in the network owns a copy of the whole database. The first
time a peer connect to the network it has to wait and get in sync with the
other peers. In the meantime, no operation is permitted. A Blockchain database
can grow a lot during the years. For example, Bitcoin's
Blockchain\footnote{N.B.: this is a 8 years old database.} size is roughly
100GB\footnote{GB = GigaByte}. This could be an issue initially for the new
members of the network. We will see how this problem can be solved.
As said in \ref{TU}, every transaction is broadcast through the network so when
the miners mine a new block every peer starts to download it.

% TODO there are more than one mining algorithm! subsection for mining
%algorithm and a paragraph for ``proof-of-work''
\subsection{Proof-of-Work}

In a Blockchain database, peers can emit new transactions in the network. These
need to be added into blocks and these blocks needs to be concatenated in order
to form a block chain. This process is performed by \textbf{miners}.
The peers have to solve a computational problem, based on the \textit{one-way}
hash property. This property says that it's computationally infeasible to find
an $x$ such that $H(x) = h$.
In every block a \textit{nonce} field is added, and miners have to found an
hash for that block that its value is less than the previous one\cite{sok15}.
The only solution to solve this problem is to try every possible nonce
combination that result in an hash that is less than the previous. Every time a
new block is added to the block chain, the problem becomes computationally more
difficult to solve.
When two different miners found a different solution a fork can happen. As
already said above (\ref{fork}), only the longest chain is kept eventually.

Every time a puzzle is solved the miners (that can form groups called
\textit{pools}) typically gain a reward. This reward is important to keep miners
working on the blockchain. Also, we will see how this reward is important when
a Blockchain database is used in a cryptocurrency.

This method was proposed for preventing abuse such e-mail spam, and for this
reason is called \textit{proof-of-work}\cite{back02}.
